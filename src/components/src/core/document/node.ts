import { Attributes, composeAttributes } from './attributes';
import { Path } from './path';
import { Delta } from './text_delta';

export abstract class NodeExternalValues {
  constructor() {}
}

/// [Node] represents a node in the document tree.
///
/// It contains three parts:
///   - [type]: The type of the node to determine which block component to render it.
///   - [data]: The data of the node to determine how to render it.
///   - [children]: The children of the node.
///
/// Json format:
/// ```
/// {
///   'type': String,
///   'data': Map<String, Object>
///   'children': List<Node>,
/// }
/// ```
export class Node {
  /// The type of the node.
  public readonly type: string;

  /// The id of the node.
  ///
  /// If not provided, it will be generated by [nanoid].
  /// In most cases, you don't need to modify it after the node is created.
  public id: string;

  /// The parent of the node.
  public parent: Node | null = null;

  /// The children of the node.
  private _children: Node[] = [];
  private _cacheChildren: Node[] | null = null;

  /// The attributes of the node.
  private _attributes: Attributes;

  public externalValues?: NodeExternalValues;

  /// this value is used to store temporary data,
  ///   and will be cleared after the node is rendered
  public extraInfos?: Record<string, any>;

  // Render Part
  public readonly key = Math.random().toString(36);
  public readonly layerLink = {}; // Placeholder for LayerLink

  private _listeners: (() => void)[] = [];

  constructor(options: {
    type: string;
    id?: string;
    parent?: Node;
    attributes?: Attributes;
    children?: Node[];
  }) {
    this.type = options.type;
    this.id = options.id || this.generateId();
    this.parent = options.parent || null;
    this._attributes = options.attributes || {};
    
    if (options.children) {
      this._children = options.children.map(child => {
        child.unlink();
        child.parent = this;
        return child;
      });
    }
  }

  private generateId(): string {
    return Math.random().toString(36).substr(2, 6);
  }

  /// Parses a [Map] into a [Node]
  static fromJson(json: Record<string, any>): Node {
    const node = new Node({
      type: json.type as string,
      attributes: (json.data as Attributes) || {},
      children: ((json.children as any[]) || [])
        .map(child => Node.fromJson(child))
    });

    for (const child of node.children) {
      child.parent = node;
    }

    return node;
  }

  get children(): Node[] {
    if (!this._cacheChildren) {
      this._cacheChildren = [...this._children];
    }
    return this._cacheChildren;
  }

  /// The attributes of the node.
  get attributes(): Attributes {
    return { ...this._attributes };
  }

  /// The path of the node.
  get path(): Path {
    return this._computePath();
  }

  get next(): Node | null {
    if (!this.parent) return null;
    const siblings = this.parent.children;
    const index = siblings.indexOf(this);
    return index >= 0 && index < siblings.length - 1 ? siblings[index + 1] : null;
  }

  get previous(): Node | null {
    if (!this.parent) return null;
    const siblings = this.parent.children;
    const index = siblings.indexOf(this);
    return index > 0 ? siblings[index - 1] : null;
  }

  notify(): void {
    this._listeners.forEach(listener => listener());
  }

  addListener(listener: () => void): void {
    this._listeners.push(listener);
  }

  removeListener(listener: () => void): void {
    const index = this._listeners.indexOf(listener);
    if (index >= 0) {
      this._listeners.splice(index, 1);
    }
  }

  dispose(): void {
    this._listeners = [];
  }

  /// Update the attributes of the node.
  updateAttributes(attributes: Attributes): void {
    this._attributes = composeAttributes(this.attributes, attributes) || {};
    this.notify();
  }

  /// Grabs the [Node] from this [Node]s children
  /// at a given index, if the index exists.
  childAtIndexOrNull(index: number): Node | null {
    if (this.children.length <= index || index < 0) {
      return null;
    }
    return this.children[index];
  }

  childAtPath(path: Path): Node | null {
    if (path.length === 0) {
      return this;
    }

    const index = path[0];
    const child = this.childAtIndexOrNull(index);
    return child?.childAtPath(path.slice(1)) || null;
  }

  /// Inserts a [Node] at a given [index]
  ///
  /// If no [index] is supplied, inserts at the
  /// end of the [Node].
  insert(entry: Node, index?: number): void {
    const length = this._children.length;
    index = index ?? length;

    entry._resetRelationshipIfNeeded();
    entry.parent = this;

    this._cacheChildren = null;

    if (this._children.length === 0) {
      this._children.push(entry);
      this.notify();
      return;
    }

    // If index is out of range, insert at the end.
    // If index is negative, insert at the beginning.
    // If index is positive, insert at the index.
    if (index >= length) {
      this._children.push(entry);
    } else if (index <= 0) {
      this._children.unshift(entry);
    } else {
      this._children.splice(index, 0, entry);
    }

    this.notify();
  }

  insertAfter(entry: Node): void {
    if (!this.parent) return;
    
    entry._resetRelationshipIfNeeded();
    entry.parent = this.parent;
    
    const siblings = this.parent._children;
    const index = siblings.indexOf(this);
    if (index >= 0) {
      siblings.splice(index + 1, 0, entry);
      this.parent._cacheChildren = null;
      this.parent.notify();
    }
  }

  insertBefore(entry: Node): void {
    if (!this.parent) return;
    
    entry._resetRelationshipIfNeeded();
    entry.parent = this.parent;
    
    const siblings = this.parent._children;
    const index = siblings.indexOf(this);
    if (index >= 0) {
      siblings.splice(index, 0, entry);
      this.parent._cacheChildren = null;
      this.parent.notify();
    }
  }

  unlink(): boolean {
    // Add a null check to avoid unlink failure
    if (!this.parent) {
      return false;
    }
    
    const siblings = this.parent._children;
    const index = siblings.indexOf(this);
    if (index >= 0) {
      siblings.splice(index, 1);
      this.parent._cacheChildren = null;
      this.parent.notify();
      this.parent = null;
      return true;
    }
    
    return false;
  }

  // reset the relationship of the node before inserting it to another node
  //  to ensure it is not in the tree
  // otherwise, it will throw a state error
  private _resetRelationshipIfNeeded(): void {
    if (this.parent) {
      this.unlink();
    }
  }

  toString(): string {
    return `Node(id: ${this.id}, type: ${this.type}, attributes: ${JSON.stringify(this.attributes)}, children: ${this.children.length})`;
  }

  get delta(): Delta | null {
    if (Array.isArray(this.attributes.delta)) {
      return Delta.fromJson(this.attributes.delta);
    }
    return null;
  }

  toJson(): Record<string, any> {
    const map: Record<string, any> = {
      type: this.type,
    };
    
    if (this.children.length > 0) {
      map.children = this.children.map(node => node.toJson());
    }
    
    if (Object.keys(this.attributes).length > 0) {
      // filter the null value
      const filteredAttributes = Object.fromEntries(
        Object.entries(this.attributes).filter(([_, value]) => value != null)
      );
      if (Object.keys(filteredAttributes).length > 0) {
        map.data = filteredAttributes;
      }
    }
    
    return map;
  }

  /// Copy the node
  ///
  /// If the parameters are not provided, the original value will be used.
  ///
  /// Be careful of the children, they will be deep copied if not provided.
  copyWith(options: {
    type?: string;
    children?: Node[];
    attributes?: Attributes;
  } = {}): Node {
    const node = new Node({
      type: options.type || this.type,
      id: this.generateId(),
      attributes: options.attributes || { ...this.attributes },
      children: options.children || [],
    });
    
    if (!options.children && this._children.length > 0) {
      for (const child of this._children) {
        const copiedChild = child.copyWith();
        copiedChild.parent = node;
        node._children.push(copiedChild);
      }
    }
    
    node.externalValues = this.externalValues;
    node.extraInfos = this.extraInfos;
    return node;
  }

  /// Deep copy the node
  ///
  /// This is a deep copy of the node, including the children.
  deepCopy(): Node {
    return this.copyWith();
  }

  private _computePath(previous: Path = []): Path {
    const parent = this.parent;
    if (!parent) {
      return previous;
    }
    const index = parent.children.indexOf(this);
    return parent._computePath([index, ...previous]);
  }

  /// check the integrity of the document (for DEBUG only)
  checkDocumentIntegrity(): void {
    // skip the root node
    if (this.path.length > 0) {
      // if node is rendered in the tree, its parent should not be null
      const errorMessage = `Please submit an issue to https://github.com/AppFlowy-IO/appflowy-editor/issues if you see this error!
          node = ${JSON.stringify(this.toJson())}`;
      
      if (!this.parent) {
        throw new Error(errorMessage);
      }
      
      // also, its parent should contain this node
      const matchingChildren = this.parent.children.filter(child => child.id === this.id);
      if (matchingChildren.length !== 1) {
        throw new Error(errorMessage);
      }
    }

    for (const child of this.children) {
      child.checkDocumentIntegrity();
    }
  }
}

/// @deprecated Use Paragraph instead
export class TextNode extends Node {
  private _delta: Delta;

  constructor(options: {
    delta: Delta;
    children?: Node[];
    attributes?: Attributes;
  }) {
    super({
      type: 'text',
      children: options.children || [],
      attributes: options.attributes || {},
      id: '',
    });
    this._delta = options.delta;
  }

  static empty(attributes?: Attributes): TextNode {
    return new TextNode({
      delta: new Delta([{ insert: '' }]),
      attributes: attributes || {},
    });
  }

  get delta(): Delta {
    return this._delta;
  }

  set delta(v: Delta) {
    this._delta = v;
    this.notify();
  }

  toJson(): Record<string, any> {
    const map = super.toJson();
    map.delta = this.delta.toJson();
    return map;
  }

  copyWith(options: {
    type?: string;
    children?: Node[];
    attributes?: Attributes;
    delta?: Delta;
    id?: string;
  } = {}): TextNode {
    const textNode = new TextNode({
      children: options.children || [],
      attributes: options.attributes || this.attributes,
      delta: options.delta || this.delta,
    });
    
    if (!options.children && this.children.length > 0) {
      for (const child of this.children) {
        const copiedChild = child.copyWith();
        copiedChild.parent = textNode;
        textNode._children.push(copiedChild);
      }
    }
    
    return textNode;
  }

  toPlainText(): string {
    return this._delta.toPlainText();
  }
}

export function paragraphNode(): Node {
  return new Node({
    type: 'paragraph',
    attributes: {
      delta: []
    }
  });
}

export function nodeEquals(nodes1: Node[], nodes2: Node[]): boolean {
  if (nodes1.length !== nodes2.length) {
    return false;
  }
  
  for (let i = 0; i < nodes1.length; i++) {
    if (!_nodeEquals(nodes1[i], nodes2[i])) {
      return false;
    }
  }
  
  return true;
}

function _nodeEquals(base: Node, other: Node): boolean {
  return base === other ||
    (base.type === other.type &&
     nodeEquals(base.children, other.children));
}